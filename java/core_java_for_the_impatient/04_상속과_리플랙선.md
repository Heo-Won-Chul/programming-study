## 클래스 확장하기

### 슈퍼클래스와 서브클래스

- `extends` 키워드는 기존 클래스에서 파생한 새로운 클래스를 만든다.
- 서브클래스는 슈퍼클래스의 하위 집합이다.

### 서브클래스 메소드 정의와 상속

- 슈퍼 클래스의 비공개가 아닌 메소드를 호출할 수 있다.

### 메소드 오버라이딩

- 슈퍼클래스 메소드를 오버라이드 시, 메소드에 `@Override`을 붙인다.
- 오버라이드 시, 반환 타입을 서브타입으로 변경할 수 있다. (=공변 반환 타입)

### 서브클래스 생성

- 슈퍼클래스의 비공개 인스턴스 변수를 접근할 수 없는 경우에는 서브클래스 생성자에 해당 인스턴스 변수들을 초기화 해주어야 한다.

### 슈퍼클래스 할당

- 서브클래스의 객체를 슈퍼클래스 타입 변수에 할당 가능하다.
- 메소드가 호출될 때 가상 머신은 객체의 실제 클래스를 살펴보고 맞는 메소드를 찾아서 실행한다.

### 타입 변환

- 슈퍼클래스로 할당하게 되면 슈퍼클래스 메소드만 호출이 가능하다.
- `instanceof`를 활용하여 안전하게 서브클래스로 변환하여 처리할 수 있다.

### 최종 메소드와 최종 클래스

- 메소드에 `final`을 선언하면 오버라이드할 수 없다.
- 클래스에 `final`을 선언하면 상속 받을 수 없다.

### 추상 메소드와 추상 클래스

- `abstract` 키워드를 사용한다.
- 인터페이스와 달리 인스턴스 변수와 생성자를 가질 수 있다.

### 보호 접근

- `protected` 키워드를 사용한다.
- 같은 패키지에 속한 모든 클래스에서 접근이 가능하다.

### 익명 서브클래스

- 문법이 혼란스럽고 비효율적이기 때문에 사용하지 않을 것이 좋다.

### 상속과 기본 메소드

- 인터페이스와 슈퍼클래스의 메소드가 같다면, 슈퍼클래스 구현이 우선시 된다.

### super를 이용한 메소드 표현식

- `super::인스턴스메소드`


## Object: 보편적 슈퍼클래스

- 자바의 모든 클래스는 Object 클래스를 직접접/간접적으로 확장한다.

### toString 메소드

- 클래스명 뒤에 인스턴스 변수 목록을 대괄호에 감싸서 나열하는 형식을 많이 따른다.

### equals 메소드

- 동일성 검사(두 객체가 같은 내용을 담고 있는지 판단)
- `Double.equals` 나 `Objects.equals` 같은 메소드를 활용할 수도 있다.
- 서브클래스의 equals 메소드를 정의할 시, 슈퍼클래스의 equals 메소드로 검사하고 서브클래스를 검사한다.
	- 이 상황에서 `instanceof`로 검사하는 것은 위험하다.
	- 서브 클래스가 여러 개라는 것을 고려하지 않은 상황이기 떄문이다.

### hashCode 메소드

- 객체에서 파생되는 정숫값이다.
- hashCode와 equals는 반드시 호환되어야 한다.
	- 동일한 형태로 해시코드가 만들어지기 때문이다.
- `Objects.hash()`

### 객체 복제하기

- `clone()`
- 복잡해질 뿐만 아니라 필요한 경우가 드물다. (표준 라이브러리 클래스 중 5% 미만만이 clone이 구현되어 있다.)


## 열거

### 열거의 메소드

- `equals` 메소드가 필요없다.
- `valueOf` 메소드는 주어진 이름에 해당하는 인스턴스를 가져온다. 없으면 예외를 반환한다.
- `values` 메소드는 해당 열거타입의 모든 인스턴스를 배열로 반환한다.

### 생성자, 메소드, 필드

- 열거의 생성자는 반드시 비공개이다. (private는 생략이 가능하다.)

### 인스턴스의 구현부

- 인스턴스 각각에 메소드를 추가할 수 있다. (ex. 연산자 기능)

### 정적 멤버

- 정적 멤버를 가질 수 있으나 생성자에서 접근이 불가능하기 때문에 정적 초기화 블록을 이용한다.

### 열거를 기준으로 스위치하기

- switch문에 열거 상수로 사용할 수 있다.


## 실행 시간 타입 정보와 리소스

- `equals`와 `toString`를 구현

### Class 클래스

- 객체의 더 많은 정보를 얻을 때 사용한다.
- `Class.forName` 등으로 객체를 얻을 수도 있다. (리플랙션)
- 클래스 객체 비교는 책을 참고한다.

### 리소스 로드하기

- `getResourceAsStream` 으로 리소스를 넣을 수 있다.

### 클래스 로더

- 바이트를 로드해서 가상 머신의 클래스나 인터페이스로 변환하는 역할을 한다.
- 자바 프로그램이 실행될 때
	1. 부트스트랩 클래스 로더 : 가상 머신의 일부, 자바 라이브러리 클래스를 로드 (re.jar)
	2. 확장 클래스 로더 : 표준 확장을 로드 (ext/\*.jar)
	3. 시스템 클래스 로더 : 애플리케이션 클래스를 로드

### 컨텍스트 클래스 로더

- 클래스로더 사용 시, 또 다른 클래스 로더로 사용 되는 것을 주의해야 한다.
	1. 사용할 클래스 로더를 넘겨준다.
	2. 현재 Thread에 사용 되는 컨텍스트 클래스로더를 사용한다.

### 서비스 로더

- 공용 인퍼테이스를 준수하는 플러그인 로드 가능하다.


## 리플렉션

- 실행 시간에 객체의 내용을 조사하고, 해당 객체의 메소드를 호출 가능하다.
- 도구 개발자가 관심을 두는 주제이다.

### 클래스 멤버 나열하기

- `java.lang.reflect 패키지`에 속한 Field, Method, Constructor가 있다.
- 위 클래스에는 모두 `getModifiers` 메소드가 있다. 사용된 제어자를 정수로 반환한다.

### 객체 조사하기

- Field를 가져올 때, `get`을 사용하면 해당 타입의 래퍼 객체를 가져온다.
- 비공개라면, `setAccessible(true)`로 접근을 가능하게 해준다.

### 메소드 호출하기

- `invoke` 메소드로 해당 메소드를 호출한다.

### 객체 생성하기

- `newInstance` 메소드를 사용하면 객체를 생성할 수 있다.

### 자바빈즈

- `getter/setter` == `getReadMethod/getWriteMethod`

### 배열 다루기

- `isArray`: 배열 여부
- `getComponentType`: 해당 Class 반환

### 프록시

- `InvocationHandler 인터페이스`를 구현한 클래스
