## 제네릭 클래스


- 꺽쇠 괄호(`< >`) 안에 타입 파라미터를 명시한다.
- 기본 타입을 제외한 것을 타입 파라미터로 받는다.


## 제네릭 메소드

- 제어자와 반환 타입 사이에 타입 파라미터를 명시한다. 
- 메소드 호출시에는 컴파일러에서 파라미터와 반환 타입에서 타입 파라미터를 추론하기 때문에 명시하지 않아도 된다.


## 타입 경계

- `extends` 키워드를 사용한다.
- 타입을 제한 해야하는 경우에 사용한다.

```text
T extends AutoCloseable
```


## 타입 가변성과 와일드카드

- 공변성을 보장해주는 것을 막기 위해 제네릭 타입을 이용하여 **불변성**을 보장해준다.

### 서브타입 와일드카드

```text
? extends AutoCloseable
```

### 슈퍼타입 와일드카드

- 반공변 상태로 만들 수 있다.

```text
? super AutoCloseable
```

> PECS : 생산자에서는 extends, 소비자에서는 super를 사용한다.

### 타입 변수와 함께 사용하는 와일드카드

```text
? super E
? extends E
```

### 경계 없는 와일드카드

- **와일드카드 캡처** : ?를 모르더라도 제네릭 메소드를 호출할 수 있다.


## 자바 가상 머신에서의 제네릭

### 타입 소거

- 제네릭 타입을 정의하면 해당 타입은 **raw 타입**으로 커파일 된다.

```text
Entry<K, V> => Entry / Object, Object
```

### 타입 변환 연산자 삽입

- 해당 타입에 대해 완벽히 보장 받는다.

```java
Entry<String, Integer> entry = ...;
String key = entry.getKey();

// compile...

Entry entry = ...;
String key = (String) entry.getKey();
```

### 브릿지 메소드

- 이름, 파라미터 타입, 반환 타입으로 메소드 쌍을 만들어낸다.


## 제네릭의 제약

- 불편한 요소(?)가 존재한다.

### 기본 타입 인자가 없다.

- 타입 파라미터는 **절대** 기본 타입이 될 수 없다. (오토박싱 기능으로 대체)

### 실행 시간에는 모든 타입이 **raw 타입**이다.

- ex) ArrayList 안에 String 객체를 담고 있는지 알 수 없다.
- `Collections.checkedList()`를 이용하여 검사한다.

### 타입 변수의 인스턴스를 만들 수 없다.

- `T t = new T()` 같은 형태가 불가능하다.

### 파라미터화된 타입의 배열을 생성할 수 없다.

```java
Entry<String, Integer>[] entries = new Entry<String, Integer>[100] // 불가능
``` 

### 정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다.

- static 변수나 메소드에서는 타입 변수를 사용할 수 없다.

### 메소드가 소거 후 충돌하지 않을 수도 있다.

### 예외외 제네릭

- 예외를 던지거나 잡아낼 수 없다.


## 리플랙션과 제네릭

- 리플랙션 패키지에 속한 제네릭 클래스 용도

### Class<T> 클래스

- Class 객체가 기술하는 클래스를 타입 파라미터로 받을 수 있다.

### 가상 머신에서 제네릭 타입 정보

- 클래스, 메소드, 생성자가 제네릭이 될 수 있다.