## 인터페이스

- 클래스 간의 계약을 표현하는 메커니즘

### 인터페이스 선언하기

- `interface`
- 인터페이스의 모든 메서드는 자동으로 `public`이다.

### 인터페이스 구현하기

- 구현 클래스에 `implements` 키워드를 사용한다.

### 인터페이스 타입으로 변환하기

- 타입이 인터페이스 자체인 객체를 만들 순 없다.

### 타입 변환과 instanceof 연산자

- 가끔 슈퍼타입에서 서브 타입을 변환 하는 것이 필요하다. 이때 __타입 변환__ 을 해야 한다.
- 타입 변환 오류시에 컴파일 시간 오류나 클래스 캐스트 예외(ClassCastException)가 일어난다.
- 예외를 피하기 위해 `instanceof`를 이용하여 타입 검사를 한다.

### 인터페이스 확장하기

- 확장하고하자는 인터페이스에 `extends` 키워드를 사용한다.

### 여러 인터페이스 구현하기

- 클래스는 여러 인터페이스를 구현할 수 있다.

### 상수

- 인터페이스에 정의한 변수는 `public static final` 이다.
- 하지만, 이런 상수 집합의 경우 열거(enum)를 사용하는 것이 좋다.


## 정적 메소드와 기본 메소드

- 자바 8 이후에는 인터페이스에 메소드를 구현할 수 있다.

### 정적 메소드

- 팩토리 메소드 경우에 사용할 수 있다.

```java
public interface IntRequence {

    public static IntRequence digitOf(int n) {
        return new DigitRequence(n);
    }
}
```

###  기본 메소드

- 구현 시, `default 제어자`를 붙여야 한다.

```java
public interface IntRequence {

    default boolean hasNext() {
        return true;
    }

    int next();
}
```

- 고전적인 패턴(자바 API의 Collection/AbstractCollection)이 종지부를 찍고, 변화할 것 이다.

### 기본 메소드의 충돌 해결하기

- 인터페이스를 다중 구현 시에 동일한 타입, 이름, 매개변수을 가진 기본 메소드라면 충돌이 날 수 있다.
- 이를 오버라이딩하여 충돌한 메소드 중 하나로 위임해야 한다.


## 인터페이스의 예

- 자주 사용하는 인터페이스로 그 의 중요성

### Comparable 인터페이스

- `정렬`을 결정할 수 있는 인터페이스
- `compareTo()`를 구현한다.

### Comparator 인터페이스

- `정렬`을 결정할 수 있는 인터페이스
- `compareTo()`를 구현한다.
- __Comparable__ 와 달리, `sort(T t, Comparator c)`에 사용된다.

### Runnable 인터페이스

- `태스크` 정의 인터페이스
- `run()`를 구현한다.

### 사용자 인터페이스 콜백

- GUI에서 동작에 대한 콜백같은 인터페이스
- `EventHandler` 인터페이스를 구현


## 람다 표현식

- 나중에 실행할 수 있게 전달하는 코드 블록
- 특정 인터페이스를 구현하는 클래스의 인스턴스로 표현이 가능하다.

### 람다 표현식 문법

- `->` 연산자를 사용한다.
- 왜 람다일까?
    - 수학 함수에 파라미터를 표기하는데 쓰임

### 함수형 인터페이스

- 람다표현식은 인터페이스와 호환된다.
- 하지만 모든 인터페이스가 아니라, 추상 메소드가 한 개만 포함된 인터페이스에만 사용 가능하다.


## 메소드 참조와 생성자 참조

- 람다 표현식보다 더 짧은 문법

### 메소드 참조

- `::` 연산자를 사용한다.
    - 클래스::인스턴스메소드
    - 클래스::정적메소드
    - 객체::인스턴스메소드
- ex)

```java
Arrays.sort(strings, (s1, s2) -> s1.compareToIgnore(s2));
// =
Arrays.sort(strings, String::compareToIgnore);
```

- `this` 또는 `super`를 캡처할 수 있다.

### 생성자 참조

- 생성 시에 new를 활용
- ex)

```java
new Employee();
// =
(Employee::new)
```


## 람다 표현식 처리하기

### 지연 실행 구현하기

- 람다를 사용하는 핵심 목적은 __지연 실행__ 이다.
    - 별도의 스레드에서 코드 실행
    - 코드를 여러 번 실행
    - 알고리즘의 올바른 지점에서 코드 실행(ex. 정렬)
    - 동작에 따른 코드 실행
    - 필요에 따른 코드 실행

### 함수형 인터페이스 고르기

- [3.6.2] 참고

### 자신만의 함수형 인터페이스 구현하기

- 인터페이스 구현시, `@FunctionalInterface`를 붙여야 한다.
    - 컴파일러가 추상메소드 하나만 있는 인터페이스인지 검사
    - 자바독 페이지에 해당 인터페이스가 함수형 인터페이스임을 표기


## 람다 표현식과 변수 유효 범위

### 람다 표현식의 유효 범위

- 중복 블록과 같다.
    - 이름 충돌 규칙 : 람다 안에 지역 변수와 이름이 같은 파라미터나 변수 선언이 안된다.
    - 이름 가리기 규칙 : `this` 키워드는 람다로 표현한 코드 블록의 인스턴스가 아니라 감싼 객체를 의미한다.

### 바깥쪽 유효 범위에 속한 변수 접근하기

- 어떻게? 가령 메소드 내부에 쓰레드를 생성한다면 메소드가 끝나고 난 뒤에는 변수에 대한 참조가 안된다고 생각할 수 있느다. 람다 표현식에 대한 이해가 필요하다.
    - 코드 블록
    - 파라미터
    - 자유 변수들의 값(파라미터 변수도 아니고 코드 내부에 선언한 변수도 아닌 것)

- 람다 표현식에서는 이런 자유 변수들의 값들을 캡처했다고 표현한다.
- 자유 변수의 값을 사용하는 코드 블록을 __클로저__ 라고 한다. 람다 표현식이 곧 __클로저__ 이다.
- 예외적으로 자유 변수는 변하지 않는 변수만 참조할 수 있다.


## 고차 함수

- 함수를 처리하거나 반환하는 함수를 `고차 함수`라 한다.
- 간단하게 Comparator 인터페이스의 고차 함수를 찾아보자.

### 함수를 반환하는 메소드

- ex) 오름차순, 내림차순 정렬을 할 수 있는 Comparator

```java
public static Comparator<String> compareInDirection(int direction) {
    return (x, y) -> direction * x.compareTo(y);
}

//...

Arrays.sort(friends, compareInDirection(1));
Arrays.sort(friends, compareInDirection(-1));
```

### 함수를 수정하는 메소드

- 매개변수로 함수형 인터페이스를 넘겨주고 수정된 함수를 반환한다.
- ex) reverse 구현

```java
public static Comparator<String> reverse(Comparator<String> comp) {
    return (x, y) -> comp.compare(y, x);
}
```

### Comparator 인터페이스의 메소드

- 유용한 고차 함수가 정적 메소드로 정의되어 있다.
    - comparing : 기준이 되는 값을 비교
    - thenComparing : 추가 비교
    - nullFirst : 비교 값이 null이면 맨 앞으로 보냄
    - nullLast : 비교 값이 null이면 맨 뒤로 보냄
    - naturalOrder : Comparable을 구현한 클래스로부터 비교자를 생성
    - reverseOrder : 자연 순서를 역순으로 정렬

- `comparing` 메소드는 가변인자를 받기 떄문에 여러가지 조건을 추가 해도 된다.


## 지역 내부 클래스

### 지역 클래스

- 메소드 안에 클래스를 정의

### 익명 클래스

- 인터페이스에 대한 구현할 클래스를 생성
