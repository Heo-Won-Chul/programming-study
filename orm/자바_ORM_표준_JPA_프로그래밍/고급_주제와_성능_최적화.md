### 예외처리
- JPA 표준 예외는 `javax.persistence.PersistenceException`의 자식 클래스
- 스프링에서는 `PersistenceExceptionTranslationPostProcessor`를 활용하여 JPA 표준 예외를 스프링 예외로 변경하여 추상화 해준다,

> 트랜잭션 롤백시, 영속성 컨텍스트가 남아 있고 이를 그대로 사용하는 것은 위험하다. 하지만 스프링에서는 전략에 따라 다르지만 기본 전략인 트랜잭션당 영속성 컨텍스트 전략은 AOP에서 함께 종료시켜준다. (OSIV에 겅우는 다르다.)

### 프록시
- 다시 봐야할 듯..

### 성능 최적화

#### N + 1 문제
- 가장 일반적인 방법은 **페치 조인**을 사용하는 것이다.
- 하이버네이트
    - `@BatchSize`
    - `@Fetch`

#### 읽기 전용 쿼리의 성능 최적화
- 데이터 조작이 필요없는 엔티티의 경우에는 영속성 컨텍스트의 관리가 필요하지 않을 수 있다.
- 방법
    1. 스칼라 타입으로 조회(필드를 따로따로)
    2. 읽기 전용 쿼리 힌트 사용(`setHint("org.hibernate.readOnly", true)`)
    3. 읽기 전용 트랜잭션 사용(`@Transactional(readOnly=true)`)

> 2, 3을 동시에 사용하는 것이 효과적이다.

#### 배치 처리
- 한번에 많은 엔티티를 로드하면 영속성 컨테스트에 많은 엔티티가 쌓이면서 메모리 부족 오류가 발생할 수 있다.
- 일정 단위마다 영속성 컨텍스트를 flush와 clear를 해줘야 한다.
- 방법
    1. 페이징
    2. Cursor(하이버네이트의 `ScrollableResults`)
    3. 하이버네이트 무상태 세션 사용(`StatelessSession`)
        - 영속성 컨텍스트의 관리도 받지 않고 2차 캐시도 사용하지 않는다.

#### SQL 쿼리 힌트
- 하이버네이트만 지원

#### 트랜잭션 쓰기 지연과 성능 최적화
- `hibernate.jdbc.batch_size`

> 트랜잭션의 쓰기 지연과 변경 감지의 진짜 장점은 **데이터베이스 테이블 로우에 락이 걸리는 시간을 최소화 한다**는 점이다.
